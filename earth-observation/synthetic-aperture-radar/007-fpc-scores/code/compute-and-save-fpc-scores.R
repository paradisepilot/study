
compute.and.save.fpc.scores <- function(
    DF.preprocessed      = NULL,
    RData.trained.engine = NULL,
    variable             = NULL,
    ncdf4.output         = NULL,
    CSV.partitions       = "DF-partitions-scores.csv",
    n.cores              = 1, # parallel::detectCores()
    n.partitions.lat     = 30,
    n.partitions.lon     = 30,
    directory.fpc.scores = "tmp-fpc-scores",
    directory.log        = "logs",
    parquet.file.stem    = "DF-tidy-scores"
    ) {

    thisFunctionName <- "compute.and.save.fpc.scores";

    cat("\n### ~~~~~~~~~~~~~~~~~~~~ ###");
    cat(paste0("\n# ",thisFunctionName,"() starts.\n"));

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    if ( file.exists(CSV.partitions) ) {
        DF.partitions <- read.csv(file = CSV.partitions, row.names = NULL);
    } else {
        DF.partitions <- compute.and.save.fpc.scores_get.DF.partitions(
            ncdf4.spatiotemporal = DF.preprocessed[1,'nc_file'],
            n.partitions.lat     = n.partitions.lat,
            n.partitions.lon     = n.partitions.lon
            );
        cat("\nstr(DF.partitions)\n");
        print( str(DF.partitions)   );
        write.csv(
            x         = DF.partitions,
            file      = CSV.partitions,
            row.names = FALSE
            );
        }
    base::gc();

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    for ( index.year in seq(1,nrow(DF.preprocessed)) ) {

        temp.year    <- DF.preprocessed[index.year,'year'   ];
        temp.nc.file <- DF.preprocessed[index.year,'nc_file'];

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        directory.year.fpc.scores <- file.path(directory.fpc.scores,temp.year);
        if ( dir.exists(directory.year.fpc.scores) ) {
            cat("\nThe directory ",directory.year.fpc.scores," already exists; skipping computation of corresponding FPC scores.\n");
            next;
            }

        parquet.tidy.scores <- paste0(parquet.file.stem,"-",temp.year,".parquet");

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        compute.and.save.fpc.scores_parallel(
            DF.partitions        = DF.partitions,
            ncdf4.spatiotemporal = temp.nc.file,
            RData.trained.engine = RData.trained.engine,
            year                 = temp.year,
            variable             = variable,
            n.cores              = n.cores,
            directory.fpc.scores = directory.year.fpc.scores,
            directory.log        = file.path(directory.log,temp.year)
            );
        base::Sys.sleep(time = 5);
        base::gc();

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        if ( file.exists(parquet.tidy.scores) ) {
            DF.tidy.scores <- arrow::read_parquet(file = parquet.tidy.scores);
        } else {
            DF.tidy.scores <- data.frame();
            for ( index.partition in seq(1,nrow(DF.partitions)) ) {
                cat("\nprocessing DF.partitions: ",index.partition," of ",nrow(DF.partitions)," rows", sep = "");
                DF.temp <- arrow::read_parquet(
                    file = file.path(directory.year.fpc.scores,DF.partitions[index.partition,'fpc.scores.parquet'])
                    );
                DF.tidy.scores <- rbind(DF.tidy.scores,DF.temp);
                base::remove(list = c('DF.temp'));
                base::gc();
                }
            cat("\n");
            base::Sys.sleep(time = 5);
            base::gc();
            arrow::write_parquet(
                x    = DF.tidy.scores,
                sink = parquet.tidy.scores
                );
            base::Sys.sleep(time = 5);
            base::gc();
            }
        cat("\nstr(DF.tidy.scores)\n");
        print( str(DF.tidy.scores)   );

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        base::Sys.sleep(time = 5);
        base::remove(list = c("DF.tidy.scores"));
        base::gc();

        } # for ( temp.year in years ) { }

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    base::remove(list = c("DF.partitions"));
    base::gc();

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    cat(paste0("\n# ",thisFunctionName,"() exits."));
    cat("\n### ~~~~~~~~~~~~~~~~~~~~ ###\n");
    return( NULL );

    }

##################################################
compute.and.save.fpc.scores_parallel <- function(
    DF.partitions        = NULL,
    ncdf4.spatiotemporal = NULL,
    RData.trained.engine = NULL,
    year                 = NULL,
    variable             = NULL,
    n.cores              = NULL,
    directory.fpc.scores = "tmp-fpc-scores",
    directory.log        = "logs"
    ) {

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    require(foreach);
    require(parallel);
    require(doParallel);
    require(tidyr);

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    doParallel::registerDoParallel(n.cores);

  # foreach ( partition.index = seq(1,4) ) %dopar% {
    foreach ( partition.index = seq(1,nrow(DF.partitions)) ) %dopar% {

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        lat.start <- DF.partitions[partition.index,'lat.start'];
        lon.start <- DF.partitions[partition.index,'lon.start'];

        lat.count <- DF.partitions[partition.index,'lat.count'];
        lon.count <- DF.partitions[partition.index,'lon.count'];

        file.stem <- DF.partitions[partition.index,'file.stem'];

        fpc.scores.parquet <- DF.partitions[partition.index,'fpc.scores.parquet'];

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        directory.original <- getwd();
        directory.log      <- file.path(directory.original,directory.log);
        directory.tmp      <- file.path(directory.original,directory.fpc.scores);

        if ( !dir.exists(directory.log) ) {
            dir.create(path = directory.log, recursive = TRUE);
            }

        if ( !dir.exists(directory.tmp) ) {
            dir.create(path = directory.tmp, recursive = TRUE);
            }

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        file.sink.out <- paste0("sink-",file.stem,".out");
        file.sink.out <- file(description = file.path(directory.log,file.sink.out), open = "wt");
        sink(file = file.sink.out, type = "output" );

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        cat("\n### ~~~~~~~~~~~~~~~~~~~~ ###\n");

        # print system time to log
        cat(paste0("\n##### Sys.time(): ",Sys.time(),"\n"));

        start.proc.time <- proc.time();

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        base::Sys.sleep(sample(x = 5:10, size = 1));
        ncdf4.object.spatiotemporal <- ncdf4::nc_open(ncdf4.spatiotemporal);
        DF.tidy <- nc_getTidyData.byLatLonYear(
            ncdf4.object = ncdf4.object.spatiotemporal,
            varid        = variable,
            year         = year,
            lat.start    = lat.start,
            lat.count    = lat.count,
            lon.start    = lon.start,
            lon.count    = lon.count
            );
        base::gc();
        ncdf4::nc_close(ncdf4.object.spatiotemporal);

        DF.tidy[,'lat_lon'] <- apply(
             X      = DF.tidy[,c('lat','lon')],
             MARGIN = 1,
             FUN    = function(x) { return( paste(x = x, collapse = "_") ) }
             );

        cat("\nstr(DF.tidy)\n");
        print( str(DF.tidy)   );

        cat("\nsummary(DF.tidy)\n");
        print( summary(DF.tidy)   );

        DF.tidy[is.na(DF.tidy[,variable]),variable] <- (-60);

        cat("\nsummary(DF.tidy) -- after setting NA to -60\n");
        print( summary(DF.tidy)   );

        arrow::write_parquet(
            x    = DF.tidy,
            sink = file.path(directory.tmp,paste0("tidy-",file.stem,".parquet"))
            );

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        base::Sys.sleep(sample(x = 5:10, size = 1));
        trained.fpc.FeatureEngine <- readRDS(RData.trained.engine);
        DF.scores <- trained.fpc.FeatureEngine$transform(
            newdata  = DF.tidy,
            location = 'lat_lon',
            date     = 'date',
            variable = variable
            );
        base::gc();
        retained.colnames <- grep(x = colnames(DF.scores), pattern = "^[0-9]+$", invert = TRUE, value = TRUE);
        DF.scores <- DF.scores[,retained.colnames];
        DF.scores <- as.data.frame(tidyr::separate(
            data = DF.scores,
            col  = 'lat_lon',
            into = c('lat','lon'),
            sep  = "_"
            ));
        DF.scores <- DF.scores[,setdiff(colnames(DF.scores),c('lat_lon'))];
        DF.scores[,'lat'] <- as.numeric(DF.scores[,'lat']);
        DF.scores[,'lon'] <- as.numeric(DF.scores[,'lon']);
        cat("\nstr(DF.scores)\n");
        print( str(DF.scores)   );
        arrow::write_parquet(
            x    = DF.scores,
            sink = file.path(directory.tmp,fpc.scores.parquet)
            );

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        base::remove(list = c(
            "DF.scores","trained.fpc.FeatureEngine",
            "DF.tidy",
            "lat.start","lat.count","lon.start","lon.count",
            "file.stem","file.sink.out","file.sink.msg"
            ));
        base::gc();

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        cat("\nshowConnections()\n");
        print( showConnections()   );

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        cat("\n### ~~~~~~~~~~~~~~~~~~~~ ###\n");
        # print warning messages to log
        cat("\n##### warnings()\n")
        print(warnings());

        # print session info to log
        cat("\n##### sessionInfo()\n")
        print( sessionInfo() );

        # print system time to log
        cat(paste0("\n##### Sys.time(): ",Sys.time(),"\n"));

        # print elapsed time to log
        stop.proc.time <- proc.time();
        cat("\n##### start.proc.time() - stop.proc.time()\n");
        print( stop.proc.time - start.proc.time );

        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        sink(file = NULL, type = "output" );
        sink();

        base::Sys.sleep(time = 5);

        } # foreach () {}
    doParallel::stopImplicitCluster();

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    return( NULL );

    }

compute.and.save.fpc.scores_get.DF.partitions <- function(
    ncdf4.spatiotemporal = NULL,
    n.partitions.lat     = 10,
    n.partitions.lon     = 10
    ) {

    require(ncdf4);

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    if ( "ncdf4" == class(ncdf4.spatiotemporal) ) {
        length.lat <- ncdf4.spatiotemporal[['dim']][['lat']][['len']];
        length.lon <- ncdf4.spatiotemporal[['dim']][['lon']][['len']];
    } else {
        ncdf4.object.spatiotemporal <- ncdf4::nc_open(ncdf4.spatiotemporal);
        length.lat <- ncdf4.object.spatiotemporal[['dim']][['lat']][['len']];
        length.lon <- ncdf4.object.spatiotemporal[['dim']][['lon']][['len']];
        ncdf4::nc_close(ncdf4.object.spatiotemporal);
        }

    cat("\nlength.lat\n");
    print( length.lat   );

    cat("\nlength.lon\n");
    print( length.lon   );

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    partition.size.lat <- length.lat %/% n.partitions.lat;
    partition.size.lon <- length.lon %/% n.partitions.lon;

    cat("\npartition.size.lat\n");
    print( partition.size.lat   );

    cat("\npartition.size.lon\n");
    print( partition.size.lon   );

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    starts.lat = 1 + seq(0,n.partitions.lat) * partition.size.lat;
    starts.lon = 1 + seq(0,n.partitions.lon) * partition.size.lon;

    DF.output <- expand.grid(
        lat.start = starts.lat,
        lon.start = starts.lon
        );
    DF.output[,'lat.count'] <- rep(partition.size.lat,nrow(DF.output));
    DF.output[,'lon.count'] <- rep(partition.size.lon,nrow(DF.output));
    DF.output <- DF.output[,c('lat.start','lat.count','lon.start','lon.count')];

    DF.output[,'lat.count'] <- apply(
        X      = DF.output[,c('lat.start','lat.count')],
        MARGIN = 1,
        FUN    = function(x) {return(ifelse( (sum(x)-1) > length.lat, length.lat - x[1]+1, x[2] ))}
        );

    DF.output[,'lon.count'] <- apply(
        X      = DF.output[,c('lon.start','lon.count')],
        MARGIN = 1,
        FUN    = function(x) {return(ifelse( (sum(x)-1) > length.lon, length.lon - x[1]+1, x[2] ))}
        );

    DF.output[,'lat.stop'] <- DF.output[,'lat.start'] + DF.output[,'lat.count'] - 1;
    DF.output[,'lon.stop'] <- DF.output[,'lon.start'] + DF.output[,'lon.count'] - 1;

    DF.output[,'file.stem'] <- apply(
        X      = DF.output[,c('lat.start','lon.start')],
        MARGIN = 1,
        FUN    = function(x) {
            file.stem <- paste0(
                stringr::str_pad(string = x[1], width = 5, pad = "0"),
                "-",
                stringr::str_pad(string = x[2], width = 5, pad = "0")
                );
            return( file.stem );
            }
        );

    DF.output[,'fpc.scores.parquet'] <- paste0("fpc-scores-",DF.output[,'file.stem'],".parquet");

    DF.output <- DF.output[,c('lat.start','lat.stop','lat.count','lon.start','lon.stop','lon.count','file.stem','fpc.scores.parquet')];

    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    # return( DF.output );
    return( DF.output );

    }
